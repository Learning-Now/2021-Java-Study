# 3. 일급 컬렉션
## 3-1. 일급 컬렉션이란
일급 컬렉션이란, 컬렉션(Collection)을 래핑(Wrapping)하면서, 그 외 다른 멤버 변수가 없는 상태이다.

래핑을 함으로써 다음과 같은 이점을 가지게 된다.

1. 비지니스에 종속적인 자료구조
2. 컬렉션의 불변성을 보장
3. 상태와 행위를 한 곳에서 관리
4. 이름이 있는 컬렉션

## 3-2. 비지니스에 종속적인 자료구조
```java
public class LottoService {

	private static final int LOTTO_NUMBERS_SIZE = 6;

	public void createLottoNumber() {
		List<Long> lottoNumbers = createNonDuplicationNumbers();
		validateSize(lottoNumbers);
		validateDuplicate(lottoNumbers);
	}
}
```

위 코드를 통해 로또 서비스에서 로또번호를 생성할 때마다  필요한 모든 장소에서 검증로직이 들어가야한다. 따라서 불필요한 코드가 중복적으로 실행된다.
이를 해결하기 위해 해당 조건으로만 생성할 수 있는 자료구조를 만들게 되면 해결할 수 있다.

```java
public class LottoTicket {
	private static final int LOTTO_NUMBERS_SIZE = 6;
	
	private final List<Long> lottoNumbers;

	public LottoTicket(List<Long> lottoNumbers) {
		validateSize(lottoNumbers);
		validateDuplicate(lottoNumbers);
		this.lottoNumbers = lottoNumbers;
	}
}

public class LottoService {
		
	public void createLottoNumbers() {
		LottoTicket lottoTicket = new LottoTicket(createNonDuplicateNumbers());
	}
}
```
위처럼 일급 컬렉션을 사용해 비즈니스에 종속적인 자료 구조를 만들어주면 좀 더 깔끔한 코드를 만들 수 있게 된다.

## 3-3. 불변
일급 컬렉션은 **컬렉션의 불변**을 보장한다.

이때 ```final```을 사용하면 안되나 의문점이 생긴다.
```final```은 불변을 만들어주는 것이 아니라, **재할당만 금지**한다.

즉, ```final```은 ```new```를 통한 재할당은 막아주지만 ```set```을 통한 내부값 변경은 막지 못한다.

따라서 일급 컬렉션을 사용해 이를 막아준다.(set을 포함하지 않는 일급 컬렉션)

## 3-4. 상태와 행위를 한 곳에서 관리
일급 컬렉션의 세 번째 장점은 **값과 로직이 함께 존재**한다는 것이다.
-> 이 부분은 Enum 클래스의 장점과 동일하다.

```java
List<Pay> pays = Arrays.asList( 
		new Pay(NAVER_PAY, 10000),
		new Pay(NAVER_PAY, 15000);
		new Pay(KAKAO_PAY, 20000);
		new Pay(TOSS, 30000L);
}

Long naverPaySum = pays.stream()
			.filter(pay -> pay.getPayType().equals(NAVER_PAY))
			.mapToLong(Pay::getAmount)
			.sum();
```
이 코드의 경우 List에 데이터를 담고, Service 혹은 Util 클래스에서 필요한 로직을 수행한다.

이때 컬렉션과 계산 로직은 서로 관계가 있지만 위 코드에서는 표현이 안되어있다.

Pay타입의 상태에 따라 지정된 메소드에서만 계산되길 원하는데, 현재 상태로는 강제할 수 있는 수단이 없다.
또한, 위 코드는 똑같은 기능을 하는 메소드를 중복 생성할 수 있을 뿐만 아니라 계산 메소드를 누락할 수 있다.

결국 이를 해결하기 위해 계산식을 컬렉션과 함께 두 번 나누어야 한다.

```java
public class PayGroups {
    private List<Pay> pays;

    public PayGroups(List<Pay> pays) {
        this.pays = pays;
    }

    public Long getNaverPaySum() {
        return getFilteredPays(pay -> PayType.isNaverPay(pay.getPayType()));
    }

    public Long getKakaoPaySum() {
        return getFilteredPays(pay -> PayType.isKakaoPay(pay.getPayType()));
    }
}
```

이렇게 PayGroups라는 일급 컬렉션이 생김으로써 **상태와 로직이 한 곳에서 관리**된다.

## 3-5. 이름이 있는 컬렉션
마지막으로 일급 컬렉션에는 **컬렉션에 이름을 붙일 수 있다**는 장점이 있다.

같은 Pay들의 모임이지만 네이버페이의 List와 카카오페이의 List는 다르다.
그렇다면 이 둘을 구분하려면 어떻게 해야할까?
가장 흔한 방법은 변수명을 다르게 하는 것이다.

```java
List<Pay> naverPays = createNaverPays();
List<Pay> kakaoPays = createKakaoPays();
```

위 코드의 단점은 검색이 어렵고, 명확한 표현이 불가능하다는 것이다.

이러한 문제 역시 일급 컬렉션으로 쉽게 해결할 수 있다.

네이버페이 그룹과 카카오페이 그룹 각각의 일급 컬렉션을 만들면 이 컬렉션을 기반으로 용어사용과 검색이 가능하다.

```java
NaverPays naverPays = new NaverPays(createNaverPays());
KakaoPays kakaoPays = new KakaoPays(createKakaoPays());
```