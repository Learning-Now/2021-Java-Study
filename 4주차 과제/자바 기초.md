# 자바 기초
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1qPwI%2Fbtqwi2T0iat%2FYbcYgIICBzXIykpmwyeeQK%2Fimg.png)

## 산술 연산자
- 산술 연산자는 가장 많이 사용하는 연산자로 수식 계산에 사용된다. 
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLKelV%2FbtqwhyGy0Bp%2F0DN4VEH6f5SeWsQ1P1r9X0%2Fimg.png)
- 이항 연산자는 피연산자의 크기가 4byte보다 작으면 4byte(int)로 변환한 다음에 연산을 수행한다.
- 이항 연산자는 연산을 수행하기 전에 피연산자들의 타입을 일치시켜야 한다.
- int보다 크기가 작은 타입은 int로 변환한다
- ex) byte, char, short -> int

### 사칙 연산자
사칙 연산은 이미 알고 있는 것처럼 곱셈, 나눗셈, 나머지 연산자가 덧셈, 뺄셈 연산자보다 우선순위가 높으므로 먼저 처리된다.
그리고 나눗셈 연산자에서 피연산자가 정수형일 경우 0으로 나눌 수 없다.
```java
public class Operator {
 
    public static void main(String[] args) {
        
        int x = 5;
        int y = 2;
        
        System.out.printf("%d + %d = %d%n",x, y, x+y);
        System.out.printf("%d - %d = %d%n",x, y, x-y);
        System.out.printf("%d * %d = %d%n",x, y, x*y);
        System.out.printf("%d / %d = %d%n",x, y, x/y);
        System.out.printf("%d / %f = %f%n",x, (float)y, x/(float)y);
 
    }//main
 
}//class


//실행 결과
5 + 2 = 7
5 - 2 = 3
5 * 2 = 10
5 / 2 = 2
5 / 2.000000 = 2.500000
```

### 나머지 연산자
나머지 연산자는 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값이 결과이다.
나머지 연산의 용도는 다양하지만 주로 짝수, 홀수 또는 배수 검사 등에 사용된다.
```java
public class Operator {
 
    public static void main(String[] args) {
        
        int x = 5;
        int y = 2;
        
        System.out.printf("%d를 %d로 나눈 몫:%d%n",x,y,x/y);
        System.out.printf("%d를 %d로 나눈 나머지:%d%n",x,y,x%y);        
 
    }//main
 
}//class


//실행 결과
5를 2로 나눈 몫:2
5를 2로 나눈 나머지:1
```

## 비트 연산자
비트 연산자는 논리 연산자와 비슷하지만, 비트 단위로 논리 연산을 할 때 사용하는 연산자이다.
또한, 비트 단위로 왼쪽이나 오른쪽으로 전체 비트를 이동하거나, 1의 보수를 만들 때도 사용된다.
|비트 연산자|설명|
|:---:|:---:|
|&|대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)|
|\||대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)|
|^|대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)|
|~|비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산, 1의 보수)|
|<<|피연산자의 부호에 상관없이 자리를 왼쪽으로 이동시키면서 빈칸을 0으로 채움.|
|>>|오른쪽으로 이동시키기 때문에 음수인 경우 부호를 유지시켜주기 위해 빈자리를 1로 채움.|
|>>>|지정된 수만큼 비트를 전부 오른쪽으로 이동시키며, 부호에 상관없이 항상 0으로 빈자리를 채움.|
- 비트 AND 연산

![](http://www.tcpschool.com/lectures/img_php_bitwise_and.png)

- 비트 OR 연산

![](http://www.tcpschool.com/lectures/img_php_bitwise_or.png)

- 비트 XOR 연산

![](http://www.tcpschool.com/lectures/img_php_bitwise_xor.png)

- 비트 NOT 연산

![](http://www.tcpschool.com/lectures/img_php_bitwise_not.png)

- 시프트 연산
```java
int num1 = 8, num2 = -8;
① System.out.println("~ 연산자에 의한 결과 : "+ ~num1);
② System.out.println("<< 연산자에 의한 결과 : "+ (num1 << 2));
③ System.out.println(">> 연산자에 의한 결과 : "+ (num2 >> 2));
④ System.out.println(">>> 연산자에 의한 결과 : "+ (num1 >>> 2));
⑤ System.out.println(">>> 연산자에 의한 결과 : "+ (num2 >>> 2));

//실행 결과
~   연산자에 의한 결과 : -9
<<  연산자에 의한 결과 : 32
>>  연산자에 의한 결과 : -2
>>> 연산자에 의한 결과 : 2
>>> 연산자에 의한 결과 : 1073741822
```

## 관계 연산자
- true 혹은 false 값인 boolean 자료형으로 반환이 된다.  
  
|연산자|기능|연산 예|
|:---:|:---:|:---:|
|\>|왼쪽 항이 크면 참을, 아니면 거짓을 반환함.|num \> 3;|
|\<|왼쪽 항이 작으면 참, 아니면 거짓을 반환함.|num \< 3;|
|\>=|왼쪽 항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓을 반환함.|num \>= 3;|
|\<=|왼쪽 항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓을 반환함.|num \<= 3;|
|==|두 개 항의 값이 같으면 참, 아니면 거짓을 반환함.|num == 3;|
|\!=|두 개 항이 다르면 참, 아니면 거짓을 반환함.|num \!= 3;|

## 논리 연산자
- AND(&&), OR(||), NOT(\!) 세 가지의 연산자가 있으며 관계 연산자와 같이 사용되는 경우가 많다.
- 논리 연산자 역시 연산의 결과가 true 혹은 false로 반환된다.  

|연산자|기능|연산 예|
|:---:|:---:|:---:|
|&&(논리 곱)|두 항이 모두 참인 경우에만 결과 값이 참, 아니면 거짓.|booleanval = (5 \> 3) && (5 \> 2);|
|\|\|(논리 합)|두 항 중 하나의 항만 참이면 결과 값이 참, 두 항이 모두 거짓이면 결과 값은 거짓.|booleanval = (5 \> 3) \|\| (5 \< 2);|
|\!(부정)|단항 연산자. 참인 경우 거짓으로 바꾸고 거짓인 경우 참으로 바꿈.|booleanval = \!(5 \> 3);|

## instanceof
- 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.
- 주로 조건문에 사용되며, instanceof의 왼쪽에는 참조변수를, 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.
- 연산의 결과로는 boolean값인 true, false 중의 하나를 반환한다.
- instanceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
```java
public class InstanceofExam {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();

        //객체 a는 자기 자신의 객체이기 때문에 형변환 가능.
        System.out.println(a instanceof A); //true 출력

        // 객체 b는 A의 자식객체이기 때문에 A로 형변환 가능.
        System.out.println(b instanceof A); //true 출력

        // 객체 a는 B의 부모객체이기때문에 형변환 불가능.
        System.out.println(a instanceof B); //false 출력

        // 객체 b는 자기 자신의 객체이기때문에 형변환 가능.
        System.out.println(b instanceof B); //true 출력
        } // end of main
    } // end of class

class A{

}
class B extends A{ 

}
```

## assignment(=) operator
- 대입 연산자는 변수에 값을 대입할 때 사용하는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽이다.
- 자바에서는 대입 연산자를 결합하여 만든 다양한 복합 연산자를 제공한다.

|대입 연산자|설명|
|:---:|:---|
|=|왼쪽의 피연산자에 오른쪽의 피연산자를 대입|
|+=|왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|-=|왼쪽의 피연산자에 오른쪽의 피연산자를 뺀 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|*=|왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|/=|왼쪽의 피연산자에 오른쪽의 피연산자를 나눈 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|%=|왼쪽의 피연산자에 오른쪽의 피연산자를 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입|
|&=|왼쪽의 피연산자를 오른쪽의 피연산자와 비트 AND 연산한 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|\|=|왼쪽의 피연산자를 오른쪽의 피연산자와 비트 OR 연산한 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|^=|왼쪽의 피연산자를 오른쪽의 피연산자와 비트 XOR 연산한 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|\<\<=|왼쪽의 피연산자를 오른쪽의 피연산자만큼 왼쪽 시프트한 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|\>\>=|왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호를 유지하며 오른쪽 시프트한 후, 그 결과 값을 왼쪽의 피연산자에 대입|
|\>\>\>=|왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호에 상관없이 오른쪽 시프트한 후, 그 결과 값을 왼쪽의 피연산자에 대입|

## 화살표(-\>) 연산자
### 람다식이란?
```
식별자 없이 실행 가능한 함수
```
함수를 따로 만들지 않고 코드 한 줄에 함수를 써서 그것을 호출하는 방식을 말한다.
### 람다식 사용법
```
(매개변수) -> {실행문}
```
- (매개변수)는 오른쪽 중괄호 {} 블록을 실행하기 위해 필요한 값을 제공하는 역할을 한다. 
- 매개 변수의 이름은 개발자가 자유롭게 지정할 수 있으며 인자타입도 명시하지 않아도 된다.
```java
(int a, int b) -> {return a + b}
```
### 람다식 장점
- 코드를 간결하게 만들 수 있다.
- 코드가 간결하고 식에 개발자의 의도가 명확히 드러나므로 가독성이 향상된다.
- 함수를 만드는 과정없이 한 번에 처리 할 수 있어 코딩하는 시간이 줄어든다.

### 람다식 단점
- 람다를 사용하면서 만드는 무명함수는 재사용이 불가능하다.
- 디버깅이 다소 까다롭다.
- 코드가 지저분해질 수 있다.
- 재귀로 만들 경우에는 다소 부적합한 면이 있다.

## 3항 연산자
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99375E495C020AB5030B68)

## 연산자 우선 순위
|연산자 종류|연산자|
|:---:|:---:|
|최우선 연산자|\.(점), \[\], ()|
|단항 연산자|\!, ~, +, -, ++, --, (cast 자료형), instanceof|
|산술 연산자|+, -, *, /, %|
|Shift 연산자|\<\<, \>\>, \>\>\>|
|관계 연산자|\<, \>, \<=, \>=, ==, !=|
|비트 연산자|&, \|, ^|
|논리 연산자|&&, \|\||
|삼항 연산자|(조건) ? 참 : 거짓|
|배정 대입 연산자|=, *=, /=, %=, +=, -=, \<\<=, \>\>=, \>\>\>=|
|증감 후위 연산자|++, --|
|순차 연산자|,(콤마)|

## (optional) Java 13. switch 연산자
- 기존 switch 구문에 expression을 추가하였다.
- switch문의 ```case:``` 대신 ```case ->``` 가 사용 가능하다.
- break문 대신 yield 구문을 사용한다.
```java
String result = switch(n) {
	case 1 -> {
		System.out.println("one");
		yield 1;
	}
	case 2 -> {
		System.out.println("two");
		yield 2;
	}
	default -> {
		System.out.println("many");
		yield 100;
	}
}
```