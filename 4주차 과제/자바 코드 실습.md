# 자바 코드 실습
## 역할, 책임, 협력(객체지향의 사실과 오해)
### 객체지향의 목표

> 현실 세게에서 식별 가능한 개체 또는 사물은 모두 "상태"와 "행동"을 가진 객체로 볼 수 있고, 이를 소프트웨어 세계에 모방해놓은 것이 "객체지향"이다.

객체지향에 대해 공부하면서 한 번쯤은 봤을 법한 문장이다. 이 말이 완전 틀렸다고 볼 수 없지만, 오류가 분명 존재한다. 현실 세계의 객체와 소프트퉤어 세계의 객체 사이에는 분명 차이점이 있다.

예를 들어, "커피"라는 객체가 있다고 하자. 현실 세계의 커피는 스스로 양을 줄이거나 늘릴수도 없는 수동적인 존재이다. 반면 객체지향 세계에서 커피는 스스로 자신의 상태를 관리할 수 있는 자율적인 존재가 된다. 또 필요에 따라 추가적인 능력도 보유할 수 있다.

이처럼 소프트웨어 객체는 일반적으로 현실 객체가 가지지 못한 더많은 특징과 능력을 보유한 객체이다. 객체지향 설계의 목적은 현실 세계를 모방하는 것이 아니라, __새로운 세계를 창조하는 것__ 이다. 이것을 이해하는 것이 객체지향 설계의 시작이다.

>객체지향은 "클래스"가 아니라 "객체"를 지향하는 것이다.

객체지향을 생각하면 가장 먼저 "클래스"가 떠오른다. 클래스는 객체를 여러 개 만들어내는 설계도(또는 틀)이다. 객체지향이라는 소설의 주인공은 "클래스"가 아니라 "객체"이다. "클래스"의 생산물이 "객체"가 아니라, "객체"를 분류하기 위해 등장한 것이 "클래스"이다. 객체지향 설계에서 중요한 것은 어떤 클래스가 필요한가가 아니라 어떤 객체들이 어떤 메시지를 주고받으며 협력하는가이다. 코드를 담은 클래스의 관점이 아닌 메시지를 주고받는 객체 의 관점으로 애플리케이션을 바라보아야 한다.

1. 객체들이 어플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 __협력__ 이라고 한다.
2. 객체가 협력에 참여하기 위해 수행하는 로직은 __책임__ 이라고 한다.
3. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 __역할__ 을 구성한다.

### 협력
- 협력은 객체지향 세계에서 기능을 구현할 수 있는 유일한 방법이다. 두 객체 사이에서 협력은 하나의 객체가 다른 객체에게 도움을 할 때 시작된다. __메세지 전송__ 은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.

- 객체를 자율적으로 만든다는 가장 기본적인 방법은 내부 구현을 __캡슐화__ 하는 것이다.

- 메세지를 전송해서 협력을 요청하고 메세지를 수신한 객체는 도움이 필요한 경우 또 요청해서 처리한다. 즉, 이런 객체들 사이의 협력을 구성해 요청과 응답을 통해 기능이 구현된다.

### 책임
협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다. 책임이란 객체에 정의되는 응집도 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할수 있는 행동에 대해 개략적으로 서술한 문장이다. 객체의 책임은 크기 '하는 것'과 '아는 것'의 범주로 나누어 세분화 된다.

#### 하는 것
- 객체를 생성하거나 계산 수행하는 등의 스스로 하는 것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절하는 것

#### 아는 것
- 사적인 정보에 관해 아는 것
- 관련된 객체에 관해 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

### 역할
- __어떤 특정한 협력 안에서 수행하는 책임의 집합__ 을 역할이라고 부른다. 역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다. 

- 역할을 구현하는 가장 일반적인 방법은 추상클래스와 인터페이스를 사용하는 것이다. 추상클래스는 책임의 일부를 구현해 놓은 것이고, 인터페이스는 일체의 구현 없이 책임의 집합만을 나열해 놓았다는 차이가 있다.

#### 역할의 특징
- 여러 객체가 동일한 역할을 수행할 수 있다.
- 역할은 대체 가능성을 의미한다.
- 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
- 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

### 제일 중요한 것은 메세지다.
#### 메세지가 객체의 책임을 결정
메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택한다. 즉, 객체가 메세지를 선택하는 것이 아니라 __메세지가 객체를 선택__ 하게 해야한다. 두가지 중요한 이유가 있다.
1. 객체가 최소한의 인터페이스를 가질 수 있게 된다.
2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다. (how가 아닌 what만을 표현해야 한다.)

#### 행동이 상태를 결정
객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다. 협력에 적합한지를 결정하는 것은 상태가 아니라 행동이다. 객체에 필요한 상태가 무엇인지 결정하면 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.

캡슐화를 위한하지 않도록 객체의 행위를 고려하기 위해서는 항상 __협력이라는 문맥 안에서 객체를 생각__ 해야 한다. 다른 객체에게 무엇을 제공해야 하고 다른 객체로부터 무엇을 얻어야 하는지 고민해야만 훌륭한 책임을 얻을 수 있다. __상태는 단지 객체가 행동을 수행하기 위해 필요한 재료__ 일 뿐이다. 행동이 바로 객체의 책임이 된다.

### Reference
[객체지향의 사실과 오해](https://jupiny.com/2019/01/12/object-orientation-fact-and-misunderstanding/)
[역할, 책임, 협력](https://hewonjeong.github.io/role-responsibility-and-collaboration/)

## VO(Value Object)
VO란 Value Object의 약자로 값 객체를 의미한다.
오직 read만 가능하며 Getter만 가능해야 한다.

DTO와 달리 데이터 이전이 아닌 그저 단순히 저장된 값을 의미한다.
그렇기 때문에 데이터 불변 조건이 성립되어야 하므로 Setter이 존재하면 안 된다.

VO가 사용되는 경우
- 데이터가 불변이어야 하는 경우
- 저장된 값을 불러아야 하는 경우

예를 들어 서울의 지역번호를 저장하고자한다.
서울의 지역번호는 누구나 다 알듯이 02이다.
그리고 핸드폰 번호처럼 변하는게 아닌 고정된 값이다.
그렇기 때문에 위와 같이 고정된 값은 VO로 저장 후 Getter 호출 할수 있다.

다만, Setter를 사용하여 값을 수정하면 안된다는 것이다.
위와 같이 고정된 값을 사용하고 호출할 때는 VO를 사용해야한다.

### DTO(Data Transfer Object)
DTO란 Data Transfer Object란 영어 의미 그대로 데이터 이전 객체이다. 그렇기 때문에 Getter 뿐만 아니라 Setter를 사용하여 Data 이전을 할 수가 있다.

예를 들어 회원정보 객체를 만들 경우에는 DTO로 명시해야 한다.
회원의 정보(이름, 휴대폰 번호, 주소 등)은 언제든지 변할 수 있기 때문에 불변의 조건이 있으면 안 된다.

그렇기 때문에 Getter와 Setter 둘다 사용하여 데이터 이전이 가능하도록 구성해야 한다.
그리고 위와 같은 기능을 담당하는 객체이기 때문에 우리는 DTO로 명시하여야 한다.

### Reference
[VO와 DTO의 차이](https://namubada.net/376)