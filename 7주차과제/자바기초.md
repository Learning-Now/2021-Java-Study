# 2021-java-study
2021 자바 스터디 7주차 과제

# 자바 기초

## 자바 상속의 특징  
> 상속은 특정 클래스를 상속받아 그 클래스의 변수와 기능을 사용하는 것을 의미한다.
> <br> 두 클래스를 조상과 자손으로 관계를 맺어준다.
> <br> 상속을 받을 때에는 "extends" 키워드를 사용한다.


타입만 가져오고싶다면 interface 구현
<br> 타입과 구현(속성,메소드)까지 가져오려면 class 상속 사용  

### 특징
1. 선택적 상속이 불가능하다.
* 클래스의 속성이나 기능을 선택적으로 상속 받을 수 없다.
* 아예 받지 않거나, 전부 다 받거나만 가능하다.
* 상속을 받게 되면 super클래스의 모든 속성과 기능을 상속받아 사용 할 수 있다.
    * 생성자는 상속되지 않는다.
    * super 클래스에서 private로 정의된 멤버변수는 상속 가능하지만 접근은 불가능하므로 public으로 선언한 setter 또는 getter을 이용한다.
    
* 수정을 원하는 기능은 재정의 할 수 있다.(Overriding)
* 필요한 속성과 기능은 추가해 작성할 수 있다.
* 객체 생성의 경우는 재사용만 가능하고 변경과 추가는 할 수 없다.
<br>
2. 단일 상속만 가능하다.
* 다중 상속을 할 경우 몇몇 문제가 생길 수 있다. 
    * 여러 조상 중, 이름이 같은 함수가 있는 경우에 문제가 될 수있다.
    * 필요없는 부분까지 받아야한다.
    
* 그렇지만 다중 상속의 장점도 있기 때문에, 자바에서는 interface 다중 구현을 제공한다.  
<br>
  
3. 생성자는 상속되지 않는다.
* 생성자는 반드시 클래스 이름과 동일하게 써야하는데, 상속 시 클래스 이름이 달라지기 때문이다.
* 하지만 재사용을 위해 호출은 할 수 있다. 반드시 첫 줄에서만 가능하다.

## Super 키워드
> 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수이다.

인스턴스 변수의 이름과 지역 변수의 이름이 같을 경우는 인스턴스 변수 앞에 this 키워드를 사용해 구분 할 수 있었다.  
이처럼 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우는 super 키워드를 사용해 구별 할 수 있다.

### Super 예제
```
class Parent {int a = 5;}

class Child extends Parent {
    void show() {
        System.out.println(a);
        System.out.println(this.a);
        System.out.println(super.a);
    }
}

public class Inheritance{
    public static void main(String[] args){
    Child child = new Child();
    child.show();
    }
}

// 5
// 5
// 5

```
위의 예제의 경우에 a는 부모 클래스에서만 선언되어 있고, 따라서 지역 변수, this 참조 변수, super 참조 변수 모두 같은 값이 출력된다.  
<br>
<br>

```
class Parent {int a = 5;}

class Child extends Parent {
    int a = 10;
 
    void show() {
        System.out.println(a);
        System.out.println(this.a);
        System.out.println(super.a);
    }
}

public class Inheritance{
    public static void main(String[] args){
    Child child = new Child();
    child.show();
    }
}

// 10
// 10
// 5
```
위의 예제처럼 자식 클래스에서도 a가 선언되어있는 경우 지역변수와 this참조 변수는 자식 클래스에서의 값을 출력하고, super 참조 변수는 부모 클래스에서의 값을 출력한다.  

## 메소드 오버라이딩  
> 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것이다.  
> 즉, 상속 받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미한다.

### 오버라이딩의 조건
1. 메소드의 선언부는 기존 메소드와 완전히 같아야 한다.
   <br> 그렇지만 메소드의 반환 타입은 부모 클래스의 반환 타입으로 타입 변환할 수 있는 타입이라면 변경 가능하다.  
2. 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경 할 수 없다.  
3. 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언 할 수 없다.  
4. 호출하고자 하는 메소드는 부모 클래스에 존재해야 한다.  

### 오버라이딩 예제
```
class Human{
    String name;
    int age;
    public void getInformation() {System.out.println("이름:"+name+"\n나이"+age);}    
}
class Student extends Human{
    int grade;
    public void getInformation() {System.out.println("이름:"+name+"\n나이"+age+"\n학년"+grade);} 
}

public class Inheritance{
   public static void main(String[] args){
          Student student = new Student;
          student.getInfo();
   }
}

// 오버라이딩 된 자식 클래스의 getInformation이 호출 됨
```

## 다이나믹 메소드 디스패치
> 런타임에 오버라이딩 된 메소드가 실행 되는 것을 의미한다.
> 다이나믹은 런타임의 동의어로 사용, 디스패치는 어떤 메소드를 호출할 지 결정하는 것이다.  

```
public class Parent{
    public void show() {
        System.out.println("Parent show");
    }
}

public class Child extends Parent{
    @Override
    public void show() {
        System.out.println("Child show");
    }
}

public class Main{

    public static main(String[] args){
        Parent parentA = new Parent();   // Parent 참조, Parent 객체
        Parent parnetB = new Child();   // Parent 참조, Child 객체
     
        parentA.show();
        parentB.show();
    }
}

// Parent show
// Child show

```

parentB는 Parent 타입 참조 하지만, Parent 클래스에서 정의된 메소드가 실행 된다.  
컴파일 타임에는 참조 타입맘ㄴ 확인하지만, 런타임 시 JVM에서 객체의 타입을 파악하고 그 객체에 정의된 메소드를 실행한다.

### Double Dispatch
> 런타임 디스패치를 두 번 시도 하는 것
> 
```
public class Dispatch {
    interface Post {
        void postOn(SNS sns);
    }
    static class Text implements Post{
        @Override
        public void postOn(SNS sns) {
            sns.post(this);
        }
    }
    static class Picture implements Post{
        @Override
        public void postOn(SNS sns) {
            sns.post(this);
        }
    }

    interface SNS{
        void post(Text post);
        void post(Picture post);
    }
    static class Facebook implements SNS{

        @Override
        public void post(Text post) {
            System.out.println("text-facebook");
        }

        @Override
        public void post(Picture post) {
            System.out.println("picture-facebook");
        }
    };
    static class Twitter implements SNS{

        @Override
        public void post(Text post) {
            System.out.println("text-twitter");
        }

        @Override
        public void post(Picture post) {
            System.out.println("picture-twitter");
        }
    };

    public static void main(String[] args) {
        List<Post> posts = Arrays.asList(new Text(),new Picture());
        List<SNS> sns = Arrays.asList(new Facebook(),new Twitter());

        posts.forEach(p->sns.forEach(s->p.postOn(s)));
    }
}

=====================결과=====================
text-facebook
text-twitter
picture-facebook
picture-twitter
```

1. post 클래스의 구현체 중에서 어떤 클래스의 postOn 메소드를 사용할지  
2. postOn 인자로 선택된 것 중에서 어떤 post 메소드를 사용할지
-> 총 두번의 Dynamic Dispatch 사용
   

## 추상 클래스 (abstract class)
> 하나 이상의 추상 메소드를 포함하는 클래스이다.
> <br> 추상 메소드는 선언만 있고 본체는 없는 함수이다.
> <br>클래스의 공통되는 필드와 메소드를 정의한 클래스이기도 하다.

```
abstract class 클래스명 {
    abstract 리턴타입 메소드명([매개변수]);
}
```

### 추상 클래스의 특징
1. 자체적으로 객체를 생성할 수 없고, 상속을 통해 자식 클래스에서 인스턴스를 생성해야 한다.  
2. 추상 클래스는 추상 메소드, 일반 메소드, 필드(멤버변수), 생성자로 구성된다.  
3. 일반적인 상속의 특성과 동일하다.  
4. 추상 클래스를 상속받는 클래스는 추상 메소드를 반드시 오버라이딩 해야 한다.  

### 추상 클래스 예제
```
abstract class Animal { abstract void cry(); }
class Cat extends Animal { void cry() { System.out.println("냐옹"); } }
class Dog extends Animal { void cry() { System.out.println("멍"); } }
 
public class Test {
    public static void main(String[] args) {
        // Animal a = new Animal(); // 추상 클래스는 인스턴스를 생성할 수 없음.
        Cat c = new Cat();
        Dog d = new Dog();
        c.cry();
        d.cry();
    }
}

// 냐옹
// 멍
```

## final 키워드
> 변수나 메소드 또는 클래스가 변경 불가능하도록 하는 키워드

### final 클래스
fianl 클래스는 클래스를 상속받을 수 없음을 지정한다.
```
final class FinalClass {
    ...
}

class Test extends FinalClass{  // 컴파일 오류
    ...
}
```

### final 메소드
final 메소드는 더이상 오버라이딩 할 수 없음을 지정한다.
```
public class SuperClass {
    protected final int finalMethod() {...}
}
class Test extends SuperClass {
    protected int finalMethod(){...}    //컴파일 오류
}
```

### final 필드, 상수
```
public class Test {
    final int ROWS = 10;    // 상수 정의, 초기값 설정

    void foo() {
        ROWS = 20;  //컴파일 오류, 상수값 변경 불가
    }
}
```