# 2021-java-study
2021 자바 스터디 6주차 과제

# 자바 기초

## 클래스 정의하는 법
> 클래스는 객체 지향 프로그래밍의 추상화라는 개념을 직접 구현한 것이라고 할 수 있음

### 클래스의 예시(Car)
클래스(class)  
- 차(Car): 설계도  

필드(field)  
- car.modelName = "카니발"  
- car.modelYear = 2016  
- car.color = "주황색"  
- car.maxSpeed = 350

메소드(method)  
- car.accelerate()  
- car.brake()

인스턴스(instance)  
- 내 차(myCar) : 설계도에 의해 생산된 차량  
- 친구 차(friendCar) : 설계도에 의해 생산된 또 다른 차량  


### 클래스 정의하기
```
접근제어자 class 클래스이름 {

    접근제어자 필드1의타입 필드1의이름;

    접근제어자 필드2의타입 필드2의이름;

    ...

    접근제어자 메소드1의 원형

    접근제어자 메소드2의 원형

    ...

};
```

예시: Car에 대한 클래스 정의
```
public class Car{   // 접근제어자, 키워드, 클래스 이름
    private String modelName;   // 클래스 필드
    private int modelYear;
    private String color;
    private int maxSpeed;
    
    public void brake() {}  //클래스 메소드
    public void accelerate()
}
```

## 객체 만드는 방법(new 키워드 이해하기)  
> 객체를 new 연산자로 선언하고 생성함  
> Class 타입 변수명 = new 생성자 ();

### 인스턴스(객체)  
자바에서 클래스를 사용하기 위해 해당 클래스 타입의 객체를 선언한다.  
이렇게 클래스로부터 객체를 선언하는 과정을 **클래스의 인스턴스화**라고 한다.  
또한 이렇게 선언된 클래스 타입의 객체를 인스턴스라고 한다.  
즉, 인스턴스란 메모리에 할당된 객체를 의미한다.  


### new 연산자  
new 연산자는 인스턴스(객체)를 생성해주는 역할을 한다.  

1. new 연산자를 통해 **메모리(heap 영역)** 에 데이터 저장 공간을 할당 
2. 그 공간의 참조값을 객체에게 반환
3. 생성자 호출  

### Car 클래스 인스턴스화 시키기 예제  

```
Car myCar = new Car();
```
해당 예제의 객체 생성 과정
1. new 연산자가 myCar 객체에 저장될 메모리 공간 할당
2. 생성자가 myCar 객체를 초기화
3. new 연산자가 새로 생성된 객체의 주소(reference)를 myCar 변수에 저장
4. myCar을 통해 Car에 접근 가능  

## 메소드 정의하는 방법  
> 특정 작업을 수행하기 위한 명령문의 집합이라고 할 수 있음

### 메소드 정의하기
```
접근제어자 반환타입 메소드이름(매개변수목록) { // 선언부

    // 구현부

}
```
1. 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시

2. 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시

3. 메소드 이름 : 메소드를 호출하기 위한 이름을 명시

4. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시

5. 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합  

### 메소드 정의하기 예시  
리턴 값이 없을 경우 void를 사용
```
public void method1(int x){
    System.out.println("method1이 실행됩니다.");
}
```

리턴 값이 int형일 경우
```
public int method2(){
    System.out.println("mehod2가 실행됩니다.");
    
    return 5;
}
```

자바 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없지만, 메소드 오버로딩(overloading)을 이용하면, 같은 이름의 메소드를 중복해 정의할 수 있다.  
메소드 오버로딩은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 다른 메소드를 작성하는 것이다.  

## 생성자 정의하는 방법  

### 생성자(Constructor)란?
> new 연산자를 통해 인스턴스를 생성할 때 반드시 호출이 되며 객체를 초기화시키는 역할을 한다.  

### 생성자 선언
```
public 클래스(매개변수){
    ...
}
```

- 생성자의 이름은 클래스의 이름과 같아야 함  
- 생성자는 리턴 값이 없음  
- 생성자는 오버로딩이 가능하다  

### 여러가지 생성자  

Car을 인스턴스화한 예제이다.
```
Car myCar = new Car();
```

### 기본 생성자  
```
Car() {} 
```

- 모든 클래스는 생성자가 존재하며, 하나 이상을 가질 수 있다.  
- 생성자 선언을 생략했다면 컴파일러가 바이트 코드에 기본 생성자를 자동으로 추가 시킨다.
- 생성자가 하나라도 있다면, 자동으로 추가하지 않는다.

### 매개변수가 있는 생성자
- 리턴 타입이 없고, 클래스 이름과 동일 해야 함
- 매개변수를 선언해 호출 시 값을 넘겨받을 수 있음  

```
class Car {
    String color;   // 색상
    int door;   // 문의 개수
    
    Car() {}
    Car(String c, int d) {
        color = c;
        door = d;
    }
}

```

### 생성자 오버로딩
- 매개변수를 달리하여 생성자를 여러 개 선언해 다양화 시킬 수 있다.  
```
Car(){
}

Car(String model){
    this.model = model;
}

Car(String model, int maxSpeed){
    this.model = model;
    this.maxSpeed = maxSpeed;
}

```

### 생성자에서 다른 생성자 호출  
- 한 생성자에만 집중적으로 작성하고, 나머지 생성자는 그 내용을 가지고 있는 생성자를 호출 해 사용한다.  
- 이 경우에는 this() 코드를 사용
```
Car() {
}
Car(String model){
    this(model,null,0);
}
Car(String model,String color,int maxSpeed){
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
}
```

## this 키워드 이해하기
> this는 인스턴스 자기 자신을 가리키는 키워드로 객체, 자기 자신을 나타냄

### 클래스의 속성과 생성자/메소드의 매개변수의 이름이 같은 경우  
- 클래스 속성을 사용할 때 this 키워드 붙어줌  

```
public class Fruit{
    public String name;
    public String color;
    public double weight;
    
    public Fruit(String name,String color,double weight){
        this.name = name;   // Fruit 객체의 name 속성 = name매개변수
        this.color = color;
        this.weight = weight;
    }
}
```

### 클래스에 오버로딩된 다른 생성자 호출
- 생성자의 최상단에 사용되어야 함  
```
public class Fruit{
    public String name;
    public String color;
    public double weight;
    public int count;
    
    public Fruit(String name, String color){
        // 밑에 선언된 Fruit 생성자를 호출
        this(name, color, 0.0, 0)
    }
    
    public Fruit(String name, String color, double weight, int count){
        this.name = name;
        this.color = color;
        this.weight = weight;
        this.count = count;
    }
}
```

## 객체 자신의 참조값을 전달하고 싶을 때
```
public class Fruit{
    public String name;
    public String color;
    public double weight;
    public int count;
    
    public Fruit(String name, String color, double weight, int count) {
        this.name = name;
        this.color = color;
        this.weight = weight;
        this.count = count;
    }
    
    public Fruit getFruitInstance() {
        return this;
    }

}
```

# enum의 개념 및 사용법
> Enum은 Enumeration의 축약으로 열거라는 의미를 가짐
> 관련있는 상수(constant)들의 집합이라고 할 수 있음

## enum 선언 하기
```
// class 외부에서 선언
enum Day{
    Mon, Tues, Wed, Thur, Fri, Sat, Sun
    
// class 내부에서 선언
public enum Day{
    Mon, Tues, Wed, Thur, Fri, Sat, Sun
}
```

## enum 사용 하기
```
public class Test{
    public enum Day{
        Mon, Tues, Wed, Thur, Fri, Sat, Sun
    }
    
    public static void main(String[] args){
        Day day = Day.Mon;
        System.out.println(day);    // Mon
        System.out.print(Day.Wed);  // Wed
    }
}
```

## 열거 객체 메소드
**values()** : 열거 타입의 모든 열거객체들을 배열로 만들어 리턴
```
enum Day {
    Mon, Tues, Wed, Thur, Fri, Sat, Sun
}
public class Test{
    public static void main(String[] args){
    for(Day day : Day.values()){
        System.out.println(day);
        }
    }
}

// Mon
// Tues
// Wed
// Thur
// Fri
// Sat
// Sun
```

**ordinal()** : 몇번 째 열거 객체인지 반환

```
enum Day {
    Mon, Tues, Wed, Thur, Fri, Sat, Sun
}
public class Test{
    public static void main(String[] args){
        Day day = Day.Wed;
        System.out.println(day.ordinal());
    }
}
// 2
```

**valueOf()** : 매개값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체 리턴
```
enum Day {
    Mon, Tues, Wed, Thur, Fri, Sat, Sun
}
public class Test{
    public static void main(String[] args){
        Day day = Day.valueOf("Wed");
        System.out.println(day);
    }
}
// Wed
```

