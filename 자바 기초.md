# 자바 기초
## 자바 상속의 특징
> 자바에서 상속이란 부모 클래스에서 정의된 필드와 메소드를 자식 클래스가 물려받는 것이다.

### 상속이 필요한 이유
1. 공통된 특징을 가지는 클래스 사이의 멤버(필드, 메소드) 선언이 불필요하다.
2. 부모 클래스의 멤버(필드, 메소드)를 재사용함으로써 자식 클래스가 간결해진다.
3. 클래스간 계층적 분류 및 관리가 쉬워진다.

### 특징
1. 자바에서는 다중상속을 지원하지 않는다. 따라서 extends 뒤에는 단 하나의 부모 클래스만 올 수 있다.
2. 자바에서는 상속의 횟수에 제한을 두지 않는다.
3. 자바에서 상속의 최상위 조상 클래스는 java.lang.Object 클래스이다.
	- 모든 클래스는 자동으로 java.lang.Object를 상속받는다.
	- 자바 컴파일러에 의해 자동으로 이루어진다.

## super 키워드
> 자바의 슈퍼 키워드는 부모 클래스 객체를 즉시 참조할 때 사용하는 참조변수이다.

### super키워드 사용
1. 부모 클래스 인스턴스 변수를 즉시 참조할 때 사용한다.
2. super()는 부모 클래스 생성자를 즉시 호출할 때 사용한다.
3. 부모 클래스 메소드를 즉시 호출할 때 사용한다.

### super()
> 서브 클래스에서 명시적으로 슈퍼클래스의 생성자를 선택하여 호출한다.
- super(parameter)
- 인자를 이용하여 슈퍼 클래스의 적당한 생성자를 호출한다.
- 반드시 서브 클래스 생성자 코드의 제일 첫 라인에 와야한다.

```java
class Point {
	private int x, y; // 한 점을 구성하는 x, y 좌표
	public Point() {
		this.x = 0;
		this.y = 0;
	}
	public Point(int x, int y) {
		this.x = x; 
		this.y = y;
	}
	public void showPoint() { // 점의 좌표 출력
		System.out.println("(" + x + "," + y + ")");
	}
}

class ColorPoint extends Point { 
	private String color; // 점의 색
	public ColorPoint(int x, int y, String color) {
		super(x, y); // Point의 생성자 Point(x, y) 호출
		this.color = color;
	}
	public void showColorPoint() { // 컬러 점의 좌표 출력
		System.out.print(color);
		showPoint(); // Point 클래스의 showPoint() 호출
	}
}

public class SuperEx {
	public static void main(String[] args) {
		ColorPoint cp = new ColorPoint(5, 6, "blue");
		cp.showColorPoint();
	}
}

//실행 결과
blue(5,6)
```

## 메소드 오버라이딩
- 슈퍼 클래스의 메소드를 서브 클래스에서 재정의한다.
	- 슈퍼 클래스 메소드의 이름, 매개변수 타입 및 개수, 리턴 타입 등 모든 것을 동일하게 작성한다.
- 메소드 무시하기, 덮어쓰기로 번역되기도 한다.
- 동적 바인딩이 발생한다
	- 서브 클래스에 오버라이딩된 메소드가 무조건 실행되는 것이다.

### 오버라이딩 목적
- 슈퍼 클래스에 선언된 메소드를, 각 서브 클래스들이 자신만의 내용으로 새로 구현하기 위해서이다.
- 상속을 통해 '하나의 인터페이스(같은 이름)에 서로 다른 내용을 구현'이라는 객체 지향의 다형성을 실현하기 위해서이다.
	- 동적 바인딩을 통해 실행 중에 다형성을 실현한다.

```java
class Shape { // 슈퍼 클래스
	public Shape next; 
	public Shape() { next = null; }

	public void draw() {
		System.out.println("Shape");
	}
}

class Line extends Shape {
	public void draw() { // 메소드 오버라이딩
		System.out.println("Line");
	}
}

class Rect extends Shape {
	public void draw() { // 메소드 오버라이딩
		System.out.println("Rect");
	}
}

class Circle extends Shape {
	public void draw() { // 메소드 오버라이딩
		System.out.println("Circle");
	}
}

public class MethodOverridingEx {
	static void paint(Shape p) {
		p.draw(); // p가 가리키는 객체 내에 오버라이딩된 draw() 호출. 
					  // 동적 바인딩
	}

	public static void main(String[] args) {
		Line line = new Line();
		paint(line); 
		paint(new Shape()); 
		paint(new Line()); 
		paint(new Rect()); 
		paint(new Circle()); 
	}
}

//실행 결과
Line
Shape
Line
Rect
Circle
```

### 동적 바인딩 vs 정적 바인딩
- 동적 바인딩(Dynamic Binding)
	- 다형성을 사용하여 메소드를 호출할 때, 발생하는 현상이다.
	- 실행시간(Runtime). 즉, 파일을 실행하는 시점에 성격이 결정된다.
	- 실제 참조하는 객체는 서브 클래스이니 서브 클래스의 메소드를 호출한다.
- 정적 바인딩(Static Binding)
	- 컴파일(Compile) 시간에 성격이 결정된다.
	- 변수의 타입이 슈퍼 클래스이니 슈퍼 클래스의 메소드를 호출한다.

### 메소드 오버로딩 vs 메소드 오버라이딩

|비교 요소|메소드 오버로딩|메소드 오버라이딩|
|:---:|:---:|:---:|
|선언|같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 작성|서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 재작성|
|관계|동일한 클래스 내 혹은 상속 관계|상속 관계|
|목적|이름이 같은 여러 개의 메소드를 중복 작성하여 사용의 편리성 향상. 다형성 실현|슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 함. 다형성 실현|
|조건|메소드 이름은 반드시 동일하고, 매개변수 타입이나 개수가 달라야 성립|메소드의 이름, 메개변수 타입과 개수, 리턴 타입이 모두 동일하여야 성립|
|바인딩|정적 바인딩. 호출될 메소드는 컴파일 시에 결정|동적 바인딩. 실행 시간에 오버라이딩된 메소드 찾아 호출|

### Reference
[동적 바인딩 vs 정적 바인딩](https://woovictory.github.io/2020/07/05/Java-binding/)

## 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
## 추상 클래스
## final 키워드
## Object 클래스