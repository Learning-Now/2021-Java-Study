# 자바 기초
## 1. 산술 연산자
| 산술에 관한 연산자 (+,-,*,/,%)
### 1.1 덧셈 연산자
| 연산자의 좌,우 값을 더하는 연산자  

```
int a = 3;
int b = 4;
System.out.println(a+b);    // 7
```

### 1.2 뺄셈 연산자
| 연산자 좌측 값에서 우측 값을 빼는 연산자  

```
int a = 10;
int b = 4;
System.out.println(a-b);    //6
```

### 1.3 곱셈 연산자
| 연산자의 좌측 값과 우측 값을 곱하는 연산자  
```
int a = 3;
int b = 6;
System.out.println(a*b);    //18
```

### 1.4 나눗셈 연산자
| 나눗셈을 실행한 뒤 생기는 몫을 반환하는 연산자  
```
int a = 17;
int b = 3;
System.out.println(a/b);    //5
```


### 1.5 나머지 연산자
| 나눗셈 실행시 생기는 나머지를 반환하는 연산자  
```
int a = 17;
int b = 3;
System.out.println(a%b);    //2
```

## 2. 비트 연산자
| 비트 단위의 연산을 위한 연산자  

### 2.1 & 연산자
| 같은 위치의 bit간에 둘 다 1일 경우 1, AND연산  
```
A   = 10110001
B   = 11011101
---------------
A&B = 10010001
```

### 2.2 | 연산자  
| 같은 위치의 bit간에 하나라도 1일 경우 1, OR연산  
```
A   = 10110001
B   = 11011101
---------------
A|B = 11111101
```

### 2.3 ^ 연산자
| 같은 위치의 bit간에 하나만 1일 경우 1, XOR연산  
```
A   = 10110001
B   = 11011101
---------------
A^B = 01101100
```

### 2.4 ~ 연산자
| bit의 0과 1을 바꿔줌  
```
~10110001 = 01001110
```

## 3. 관계 연산자
| 비교 연산자라고도 하며 관계연산자의 결과는 boolean 자료형으로 반환  

 |연산자|기능|연산 예
|:-----:|:-------:|:----:|
| '>' | 왼쪽 항이 크면 참, 아니면 거짓 반환|num>3;|
| '<' | 왼쪽 항이 작으면 참, 아니면 거짓 반환|num<3;|
| '>=' | 왼쪽 항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓 반환|num>=3;|
| '<=' | 왼쪽 항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓 반환|num<=3;| 
| '==' | 두 개 항 값이 같으면 참, 아니면 거짓 반환|num==3;|
| '!=' | 두 개 항이 다르면 면 참, 아니면 거짓 반환|num!=3;|  
<br>

## 4. 논리 연산자
| 비교연산자를 통해 도출된 true/false에 대한 논리 조합  

|연산자|기능|연산 예
|:-----:|:-------:|:----:|
| '&&' | 두 항이 모두 참인 경우 참, 아니면 거짓 반환|val = (5>3) && (5>2);|
|'ll' | 두 항 중 하나의 항만 참이면 참, 아니면 거짓 반환|val = (5>3) || (5<2);|
| '!' | 참인 경우는 거짓으로, 거짓인 경우는 참으로 바꿈|val = !(5>3);|

## 5. instanceof
| 객체 타입을 확인하는 연산자로 형변환 가능여부를 확인함  
- true / false로 결과를 반환
- 주로 상속 관계에서 부모객체인지 자식객체인지 확인하는데 사용
- "객체 instanceof 클래스" 선언으로 사용
- 쉽게말해 해당 클래스가 자기집이 맞는지 확인해주는 것
```
Parent parent = new Parent();
Child child = new Child();

System.out.println( parent instanceof Parent );  // true
System.out.println( child instanceof Parent );   // true
System.out.println( parent instanceof Child );   // false
System.out.println( child instanceof Child );   // true
```
- 첫번째 경우, 부모가 본인 집을 찾았으니 true
- 두번째 경우, 자식이 상속받은 부모집을 찾았으니 true
- 세번째 경우, 부모가 자식집을 찾았으니 false
- 네번째 경우, 자식이 본인 집을 찾았으니 true  


## 6. assignment(=) operator(대입 연산자)
| 우측의 값을 좌측에 대입한다는 규칙을 가진 연산자
- 우측 값이 좌측에 대입되면, 우측 값은 변하지 않으나 좌측의 변수만 변함
- 기본적으로 좌측과 우측의 자료형이 동일할 때 사용가능  

```
int a = 100;    // a에 100 대입
int b = 50; //b에 50 대입
```  

## 7. 화살표(->)연산자
| 익명함수라고 불리는 람다가 등장하며 사용되는 연산자  

### 7.1 람다 함수란?
| 익명 함수(Anonymous functions)를 지칭하는 용어

#### 7.1.1 익명 함수란?  
| 함수의 이름이 없는 함수

### 7.2 람다 식이란?
| 식별자 없이 실행가능한 함수
- 함수지만 함수를 따로 만들지 않고 코드 한줄에 함수를 써서 그를 호출하는 방식

### 7.3 람다식 사용법
- (매개변수목록) -> {함수 몸체} 
- () -> {함수몸체}
- (매개변수) -> 함수몸체
- (매개변수) -> {return 0;}
```
(int x) -> x+1
(x) -> x+1
x -> x+1
(int x) -> { return x+1; }
x -> { return x+1; }
```

### 7.4 람다식 예제
#### 7.4.1 기존 자바 문법  
```
new Thread(new Runnable() {
   @Override
   public void run() { 
      System.out.println("Hello"); 
   }
}).start();
```
#### 7.4.2 람다식 문법  
```
new Thread(()->{
      System.out.println("Hello");
}).start();
```

## 8. 3항 연산자
| if/else 구조로 간단하게 쓸 수 있는 조건연산자  

### 8.1 3항 연산자의 형식
```
(조건식) ? 피연산자1(true일경우):피연산자2(false일경우)  
```
boolean 조건이 참일 경우 피연산자1    

boolean 조건이 거짓일 경우 피연산자2  

### 8.2 3항 연산자의 예제  
3항 연산자를 사용할 경우
```
int a1 = (5>4) ? 50 : 40; // 조건식이 true이므로 a1은 50
```

if-else문을 사용할 경우  
```
int a2 = 0;
if(5>4){
    a2 = 50;
}
else{
    a2 = 40;
}
```

## 9. 연산자 우선 순위  
|우선순위|연산자 종류|연산자 예|
|:---:|:-----:|:-----:|
|1|괄호|() []|
|2|전위연산자|++a, --b|
|3|산술연산자|+,=,*,/,%|
|4|시프트연산자|<<,>> 등|
|5|비교연산자|<,<=,>,>=,==,!=|
|6|대입연산자|=,+=,-=,*=,/= 등|
|7|후위연산자|a++, b--|

## 10. Java 13, switch 연산자  
- 자바 12부터 switch 연산자가 추가
  
[Java 12]  
- ->(화살표) 표현이 가능하고 data만 존재할 경우 return이 가능하다.  

- -> 구문을 사용할 경우 break;를 적지 않아도 다음 case 구문으로 넘어가지 않는다.  
   
- -> 표현 오른쪽은 꼭 단일 수행일 필요는 없다. 블록 {} 안에서의 작업도 가능하다. 

[Java 13]
- yield 예약어가 추가됨
- yield x 를 하면 x가 리턴
- yield는 예약어이지만 변수명으로 사용가능


<Java 12이전의 switch case 문법>
```
 int num = 1;
        int returnNum = 0;
        switch(num){
            case 1:
                returnNum = 1;
                System.out.println("1");
                break;
            case 2:
                returnNum = 2;
                System.out.println("2");
                break;
            case 3:
                returnNum = 3;
                System.out.println("3");
                break;
        }
```
이전 자바 switch case의 문제점  

1. 불필요하게 장황  
2. Error 발생시 디버깅이 어려움  

<Java 12의 switch case 문법>
```
  returnNum = switch(num){
            case 1 -> 1;
            case 2 -> 2;
            default -> throw new IllegalStateException("Unexpected value: " + num);
        };
```

<Java 13의 switch case 문법>
```
  returnNum = switch(num){
            case 1 : yield 3;
            default : throw new IllegalStateException("unexpected value : " + num);
        };
```

